import json
import hashlib
import httpx
import jwt
import time

from rich import print
from uuid import uuid4
from typing import Any

from jwcrypto  import jwk
from jwt import PyJWK, PyJWKClient
from starlette.requests import Request
from starlette.responses import JSONResponse

AUTH_HEADER_PREFIX = 'Bearer'

class PushNotificationAuth:
    def _calculate_request_body_sha256(self, data: dict[str, Any]):
        """
        This calculates the SHA256 hash of the request body
        Logic is same for agent who signs the payload and client verifier 
        """
        body_str = json.dumps(
            data,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(',', ':')
        )
        hash = hashlib.sha256(body_str.encode()).hexdigest()

class PushNotificationSenderAuth(PushNotificationAuth):
    def __init__(self):
        self.public_keys = []
        self.private_key_jwk: PyJWK = None

    @staticmethod
    async def verify_push_notification_url(url: str) -> bool:
        async with httpx.AsyncClient(timeout=10) as client:
            try:
                validation_token = str(uuid4())
                response = await client.get(
                    url,
                    params={'validationToken': validation_token}
                )
                response.raise_for_status()
                is_verified = response.text == validation_token
                return is_verified
            except Exception as e:
                print(f"Error occuried while verifying push notification URL:\n{e}")
        return False
    
    def generate_jwk(self):
        key = jwk.JWK.generate(
            size=2048,
            kty='RSA',
            kid=str(uuid4()),
            use='sig'
        )
        self.public_keys.append(key.export_public(as_dict=True))
        self.private_key_jwk = PyJWK.from_json(key.export_private())

    def handle_jwks_enpoint(self, _request: Request):
        """Allow clients to fetch public keys."""
        return JSONResponse({'keys': self.public_keys})

    def _generate_jwt(self, data: dict[str, Any]):
        """JWT is generated by signing both the request payload SHA digest and time of token generation

        Payload is signed with the private key and it ensures the integrity of the payload for client.
        Including iat to prevent from replay attack. 
        """
        iat = int(time.time())
        payload = {
                'iat': iat,
                'request_body_sha256': self._calculate_request_body_sha256(
                    data
                )
            }
        return jwt.encode(
            payload,
            headers={'kid': self.private_key_jwk.key_id},
            key=self.private_key_jwk,
            algorithm='RS256'
        )
    
    async def send_push_notification(self, url: str, data: dict[str, Any]):
        jwt_token = self._generate_jwt(data)
        headers = {'Authorization': f'{AUTH_HEADER_PREFIX} {jwt_token}'}
        with httpx.AsyncClient(timeout=10) as client:
            try:
                response = await  client.post(
                    url,
                    json=data,
                    headers=headers
                )
                response.raise_for_status()

            except Exception as e:
                print(f"Error occured while sending push notification:\n{e}")

class PushNotificationReceiverAuth(PushNotificationAuth):
    def __init__(self):
        self.public_keys_jwks = []
        self.jwks_client = None

    async def load_jwks(self, jwks_url: str):
        self.jwks_client = PyJWKClient(jwks_url)

    async def verify_push_notification(self, request: Request) -> bool:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith(AUTH_HEADER_PREFIX):
            print("Invalid Authorization header")
            return False
        
        token = auth_header[len(AUTH_HEADER_PREFIX)+1:]
        signing_key = self.jwks_client.get_signing_key_from_jwt(token)
        
        decoded_token = jwt.decode(
            token,
            signing_key,
            options={'require': ['iat', 'request_body_sha256']},
            algorithms=['RS256']
        )
        actual_body_sha256 = self._calculate_request_body_sha256(
            await request.json()
        )

        if actual_body_sha256 != decoded_token['request_body_sha256']:
            raise ValueError("Invalid Request body.")
        
        if time.time() -  decoded_token['iat'] > 60*5:
            raise ValueError("Token Expired!")
        return True
